{"version":3,"file":"shared-services-ARmQ2z6X.js","sources":["../../src/services/cache/CacheManager.js","../../src/services/cache/invalidation.js","../../src/services/cache/strategies.js","../../src/api/client.js"],"sourcesContent":["/**\r\n * CacheManager - LRU cache with TTL, tag-based invalidation, and size limits.\r\n *\r\n * Competency: API Response Caching\r\n * Bug surface: stale cache, race conditions, memory leaks, improper invalidation\r\n */\r\n\r\nclass CacheEntry {\r\n  constructor(key, value, options = {}) {\r\n    this.key = key;\r\n    this.value = value;\r\n    this.createdAt = Date.now();\r\n    this.lastAccessedAt = Date.now();\r\n    this.accessCount = 0;\r\n    this.ttl = options.ttl || 60000;\r\n    this.tags = options.tags || [];\r\n    this.etag = options.etag || null;\r\n  }\r\n\r\n  isExpired() {\r\n    return Date.now() - this.createdAt > this.ttl;\r\n  }\r\n\r\n  access() {\r\n    this.lastAccessedAt = Date.now();\r\n    this.accessCount++;\r\n    return this.value;\r\n  }\r\n}\r\n\r\nclass CacheManager {\r\n  constructor(options = {}) {\r\n    this.maxEntries = options.maxEntries || 100;\r\n    this.defaultTTL = options.defaultTTL || 60000;\r\n    this.cache = new Map();\r\n    this.tagIndex = new Map();\r\n    this.stats = {\r\n      hits: 0,\r\n      misses: 0,\r\n      evictions: 0,\r\n      invalidations: 0,\r\n    };\r\n  }\r\n\r\n  get(key) {\r\n    const entry = this.cache.get(key);\r\n\r\n    if (!entry) {\r\n      this.stats.misses++;\r\n      return null;\r\n    }\r\n\r\n    if (entry.isExpired()) {\r\n      this._remove(key);\r\n      this.stats.misses++;\r\n      return null;\r\n    }\r\n\r\n    this.stats.hits++;\r\n\r\n    // Move to end for LRU (Map maintains insertion order)\r\n    this.cache.delete(key);\r\n    this.cache.set(key, entry);\r\n\r\n    return entry.access();\r\n  }\r\n\r\n  set(key, value, options = {}) {\r\n    // Remove existing entry if present\r\n    if (this.cache.has(key)) {\r\n      this._remove(key);\r\n    }\r\n\r\n    // Evict LRU if at capacity\r\n    while (this.cache.size >= this.maxEntries) {\r\n      this._evictLRU();\r\n    }\r\n\r\n    const entry = new CacheEntry(key, value, {\r\n      ttl: options.ttl || this.defaultTTL,\r\n      tags: options.tags || [],\r\n      etag: options.etag || null,\r\n    });\r\n\r\n    this.cache.set(key, entry);\r\n\r\n    // Update tag index\r\n    entry.tags.forEach((tag) => {\r\n      if (!this.tagIndex.has(tag)) {\r\n        this.tagIndex.set(tag, new Set());\r\n      }\r\n      this.tagIndex.get(tag).add(key);\r\n    });\r\n\r\n    return entry;\r\n  }\r\n\r\n  has(key) {\r\n    const entry = this.cache.get(key);\r\n    if (!entry) return false;\r\n    if (entry.isExpired()) {\r\n      this._remove(key);\r\n      return false;\r\n    }\r\n    return true;\r\n  }\r\n\r\n  invalidate(key) {\r\n    this._remove(key);\r\n    this.stats.invalidations++;\r\n  }\r\n\r\n  invalidateByTag(tag) {\r\n    const keys = this.tagIndex.get(tag);\r\n    if (!keys) return 0;\r\n\r\n    let count = 0;\r\n    keys.forEach((key) => {\r\n      this._remove(key);\r\n      count++;\r\n    });\r\n\r\n    this.tagIndex.delete(tag);\r\n    this.stats.invalidations += count;\r\n    return count;\r\n  }\r\n\r\n  invalidateByPattern(pattern) {\r\n    const regex = new RegExp(pattern);\r\n    let count = 0;\r\n\r\n    const keysToRemove = [];\r\n    this.cache.forEach((_, key) => {\r\n      if (regex.test(key)) {\r\n        keysToRemove.push(key);\r\n      }\r\n    });\r\n\r\n    keysToRemove.forEach((key) => {\r\n      this._remove(key);\r\n      count++;\r\n    });\r\n\r\n    this.stats.invalidations += count;\r\n    return count;\r\n  }\r\n\r\n  getStale(key) {\r\n    const entry = this.cache.get(key);\r\n    if (!entry) return null;\r\n    return entry.value;\r\n  }\r\n\r\n  getEtag(key) {\r\n    const entry = this.cache.get(key);\r\n    return entry?.etag || null;\r\n  }\r\n\r\n  clear() {\r\n    this.cache.clear();\r\n    this.tagIndex.clear();\r\n  }\r\n\r\n  getStats() {\r\n    const hitRate =\r\n      this.stats.hits + this.stats.misses > 0\r\n        ? ((this.stats.hits / (this.stats.hits + this.stats.misses)) * 100).toFixed(1)\r\n        : '0.0';\r\n\r\n    return {\r\n      ...this.stats,\r\n      hitRate: `${hitRate}%`,\r\n      size: this.cache.size,\r\n      maxSize: this.maxEntries,\r\n    };\r\n  }\r\n\r\n  _remove(key) {\r\n    const entry = this.cache.get(key);\r\n    if (!entry) return;\r\n\r\n    // Clean up tag index\r\n    entry.tags.forEach((tag) => {\r\n      const tagKeys = this.tagIndex.get(tag);\r\n      if (tagKeys) {\r\n        tagKeys.delete(key);\r\n        if (tagKeys.size === 0) {\r\n          this.tagIndex.delete(tag);\r\n        }\r\n      }\r\n    });\r\n\r\n    this.cache.delete(key);\r\n  }\r\n\r\n  _evictLRU() {\r\n    // Map iterator gives keys in insertion order; first key is the LRU\r\n    const firstKey = this.cache.keys().next().value;\r\n    if (firstKey !== undefined) {\r\n      this._remove(firstKey);\r\n      this.stats.evictions++;\r\n    }\r\n  }\r\n}\r\n\r\nexport { CacheManager, CacheEntry };\r\n","/**\r\n * Cache invalidation utilities - tag-based and mutation-triggered invalidation.\r\n *\r\n * Competency: API Response Caching\r\n */\r\n\r\nclass CacheInvalidator {\r\n  constructor(cacheManager) {\r\n    this.cache = cacheManager;\r\n    this.mutationRules = new Map();\r\n  }\r\n\r\n  /**\r\n   * Register a rule: when a mutation happens on a resource,\r\n   * invalidate all cache entries with the specified tags.\r\n   */\r\n  registerMutationRule(resourceType, mutationType, tags) {\r\n    const key = `${resourceType}:${mutationType}`;\r\n    this.mutationRules.set(key, tags);\r\n  }\r\n\r\n  /**\r\n   * Trigger invalidation after a mutation occurs.\r\n   */\r\n  onMutation(resourceType, mutationType, payload = {}) {\r\n    const key = `${resourceType}:${mutationType}`;\r\n    const tags = this.mutationRules.get(key);\r\n\r\n    if (tags) {\r\n      let invalidated = 0;\r\n      tags.forEach((tag) => {\r\n        const tagToInvalidate = typeof tag === 'function' ? tag(payload) : tag;\r\n        invalidated += this.cache.invalidateByTag(tagToInvalidate);\r\n      });\r\n      return invalidated;\r\n    }\r\n\r\n    return 0;\r\n  }\r\n\r\n  /**\r\n   * Invalidate all cache entries related to a specific entity.\r\n   */\r\n  invalidateEntity(entityType, entityId) {\r\n    const tag = `${entityType}:${entityId}`;\r\n    return this.cache.invalidateByTag(tag);\r\n  }\r\n\r\n  /**\r\n   * Invalidate all cache entries for a collection.\r\n   */\r\n  invalidateCollection(collectionName) {\r\n    return this.cache.invalidateByTag(`collection:${collectionName}`);\r\n  }\r\n}\r\n\r\nexport { CacheInvalidator };\r\n","/**\r\n * Cache strategies: cache-first, network-first, stale-while-revalidate.\r\n *\r\n * Competency: API Response Caching\r\n * Bug surface: stale data, race conditions, error handling, rate limits\r\n */\r\n\r\n/**\r\n * Cache-first strategy: returns cached data if available, otherwise fetches from network.\r\n */\r\nasync function cacheFirst(cacheManager, key, fetchFn, options = {}) {\r\n  const cached = cacheManager.get(key);\r\n  if (cached !== null) {\r\n    return { data: cached, source: 'cache', stale: false };\r\n  }\r\n\r\n  const data = await fetchFn();\r\n  cacheManager.set(key, data, options);\r\n  return { data, source: 'network', stale: false };\r\n}\r\n\r\n/**\r\n * Network-first strategy: tries network first, falls back to cache on error.\r\n */\r\nasync function networkFirst(cacheManager, key, fetchFn, options = {}) {\r\n  try {\r\n    const data = await fetchFn();\r\n    cacheManager.set(key, data, options);\r\n    return { data, source: 'network', stale: false };\r\n  } catch (error) {\r\n    const cached = cacheManager.getStale(key);\r\n    if (cached !== null) {\r\n      return { data: cached, source: 'cache', stale: true, error };\r\n    }\r\n    throw error;\r\n  }\r\n}\r\n\r\n/**\r\n * Stale-while-revalidate: returns cached data immediately (even if stale),\r\n * then fetches fresh data in background.\r\n */\r\nfunction staleWhileRevalidate(cacheManager, key, fetchFn, options = {}) {\r\n  const cached = cacheManager.getStale(key);\r\n  const isFresh = cacheManager.has(key);\r\n\r\n  // Track the original error so we can re-throw it properly\r\n  let fetchError = null;\r\n\r\n  // Start background revalidation\r\n  const revalidatePromise = fetchFn()\r\n    .then((data) => {\r\n      cacheManager.set(key, data, options);\r\n      if (options.onRevalidated) {\r\n        options.onRevalidated(data);\r\n      }\r\n      return data;\r\n    })\r\n    .catch((error) => {\r\n      fetchError = error;\r\n      if (options.onRevalidateError) {\r\n        options.onRevalidateError(error);\r\n      }\r\n      return null;\r\n    });\r\n\r\n  if (cached !== null) {\r\n    return {\r\n      data: cached,\r\n      source: 'cache',\r\n      stale: !isFresh,\r\n      revalidating: revalidatePromise,\r\n    };\r\n  }\r\n\r\n  // No cache at all - must wait for network\r\n  return revalidatePromise.then((data) => {\r\n    if (data === null) {\r\n      // Re-throw the original error (preserves AbortError identity)\r\n      throw fetchError || new Error('Network request failed and no cached data available');\r\n    }\r\n    return { data, source: 'network', stale: false, revalidating: null };\r\n  });\r\n}\r\n\r\nexport { cacheFirst, networkFirst, staleWhileRevalidate };\r\n","/**\r\n * API Client - Handles fetch requests with rate limiting, retry, error handling,\r\n * request deduplication, and abort controller integration.\r\n *\r\n * Competency: API Response Caching\r\n * Bug surface: rate limits, race conditions, error handling, API versioning\r\n */\r\n\r\nconst DEFAULT_BASE_URL = '/api';\r\nconst MAX_RETRIES = 3;\r\nconst RETRY_DELAY_BASE = 1000;\r\n\r\n// In-flight request deduplication\r\nconst inFlightRequests = new Map();\r\n\r\nclass ApiError extends Error {\r\n  constructor(message, status, data = null) {\r\n    super(message);\r\n    this.name = 'ApiError';\r\n    this.status = status;\r\n    this.data = data;\r\n  }\r\n}\r\n\r\nclass RateLimitError extends ApiError {\r\n  constructor(retryAfter, data) {\r\n    super(`Rate limited. Retry after ${retryAfter}s`, 429, data);\r\n    this.name = 'RateLimitError';\r\n    this.retryAfter = retryAfter;\r\n  }\r\n}\r\n\r\nasync function apiClient(endpoint, options = {}) {\r\n  const {\r\n    method = 'GET',\r\n    body = null,\r\n    headers = {},\r\n    baseUrl = DEFAULT_BASE_URL,\r\n    retry = true,\r\n    maxRetries = MAX_RETRIES,\r\n    deduplicate = true,\r\n    signal = null,\r\n    version = 'v1',\r\n  } = options;\r\n\r\n  const url = `${baseUrl}/${version}${endpoint}`;\r\n\r\n  // Request deduplication for GET requests WITHOUT abort signals.\r\n  // Requests with signals are independently cancellable and must not\r\n  // be shared â€” otherwise an abort from one consumer kills every consumer.\r\n  const canDedup = method === 'GET' && deduplicate && !signal;\r\n\r\n  if (canDedup) {\r\n    const existing = inFlightRequests.get(url);\r\n    if (existing) {\r\n      return existing;\r\n    }\r\n  }\r\n\r\n  const fetchPromise = _executeFetch(url, {\r\n    method,\r\n    body,\r\n    headers,\r\n    signal,\r\n    retry,\r\n    maxRetries,\r\n    attempt: 0,\r\n  });\r\n\r\n  // Track in-flight GET requests for deduplication\r\n  if (canDedup) {\r\n    inFlightRequests.set(url, fetchPromise);\r\n    fetchPromise.then(\r\n      () => inFlightRequests.delete(url),\r\n      () => inFlightRequests.delete(url)\r\n    );\r\n  }\r\n\r\n  return fetchPromise;\r\n}\r\n\r\nasync function _executeFetch(url, options) {\r\n  const { method, body, headers, signal, retry, maxRetries, attempt } = options;\r\n\r\n  const fetchOptions = {\r\n    method,\r\n    headers: {\r\n      'Content-Type': 'application/json',\r\n      ...headers,\r\n    },\r\n  };\r\n\r\n  // Only attach signal when it's a real AbortSignal (not null/undefined)\r\n  if (signal) {\r\n    fetchOptions.signal = signal;\r\n  }\r\n\r\n  if (body && method !== 'GET') {\r\n    fetchOptions.body = JSON.stringify(body);\r\n  }\r\n\r\n  try {\r\n    const response = await fetch(url, fetchOptions);\r\n\r\n    // Handle rate limiting\r\n    if (response.status === 429) {\r\n      const retryAfter = parseInt(response.headers.get('Retry-After') || '5', 10);\r\n      const data = await response.json().catch(() => null);\r\n\r\n      if (retry && attempt < maxRetries) {\r\n        // Wait the shorter of retryAfter or 5 seconds\r\n        await _delay(Math.min(retryAfter, 5) * 1000);\r\n        return _executeFetch(url, { ...options, attempt: attempt + 1 });\r\n      }\r\n\r\n      throw new RateLimitError(retryAfter, data);\r\n    }\r\n\r\n    // Handle server errors with retry\r\n    if (response.status >= 500 && retry && attempt < maxRetries) {\r\n      const delay = RETRY_DELAY_BASE * Math.pow(2, attempt);\r\n      await _delay(delay);\r\n      return _executeFetch(url, { ...options, attempt: attempt + 1 });\r\n    }\r\n\r\n    // Handle client errors\r\n    if (!response.ok) {\r\n      const data = await response.json().catch(() => null);\r\n      throw new ApiError(\r\n        data?.error || `Request failed with status ${response.status}`,\r\n        response.status,\r\n        data\r\n      );\r\n    }\r\n\r\n    const data = await response.json();\r\n    return data;\r\n  } catch (error) {\r\n    // Don't retry aborted requests\r\n    if (error.name === 'AbortError') {\r\n      throw error;\r\n    }\r\n\r\n    // Don't retry known API errors\r\n    if (error instanceof ApiError) {\r\n      throw error;\r\n    }\r\n\r\n    // Retry network errors\r\n    if (retry && attempt < maxRetries) {\r\n      const delay = RETRY_DELAY_BASE * Math.pow(2, attempt);\r\n      await _delay(delay);\r\n      return _executeFetch(url, { ...options, attempt: attempt + 1 });\r\n    }\r\n\r\n    throw new ApiError(error.message, 0, null);\r\n  }\r\n}\r\n\r\nfunction _delay(ms) {\r\n  return new Promise((resolve) => setTimeout(resolve, ms));\r\n}\r\n\r\n// Convenience methods\r\nfunction get(endpoint, options = {}) {\r\n  return apiClient(endpoint, { ...options, method: 'GET' });\r\n}\r\n\r\nfunction post(endpoint, body, options = {}) {\r\n  return apiClient(endpoint, { ...options, method: 'POST', body });\r\n}\r\n\r\nfunction put(endpoint, body, options = {}) {\r\n  return apiClient(endpoint, { ...options, method: 'PUT', body });\r\n}\r\n\r\nfunction del(endpoint, options = {}) {\r\n  return apiClient(endpoint, { ...options, method: 'DELETE' });\r\n}\r\n\r\nexport { apiClient, get, post, put, del, ApiError, RateLimitError };\r\n"],"names":["CacheEntry","key","value","options","CacheManager","entry","tag","keys","count","pattern","regex","keysToRemove","_","hitRate","tagKeys","firstKey","CacheInvalidator","cacheManager","resourceType","mutationType","tags","payload","invalidated","tagToInvalidate","entityType","entityId","collectionName","cacheFirst","fetchFn","cached","data","networkFirst","error","staleWhileRevalidate","isFresh","fetchError","revalidatePromise","DEFAULT_BASE_URL","MAX_RETRIES","RETRY_DELAY_BASE","inFlightRequests","ApiError","message","status","RateLimitError","retryAfter","apiClient","endpoint","method","body","headers","baseUrl","retry","maxRetries","deduplicate","signal","version","url","canDedup","existing","fetchPromise","_executeFetch","attempt","fetchOptions","response","_delay","delay","ms","resolve","get"],"mappings":"AAOA,MAAMA,CAAW,CACf,YAAYC,EAAKC,EAAOC,EAAU,CAAA,EAAI,CACpC,KAAK,IAAMF,EACX,KAAK,MAAQC,EACb,KAAK,UAAY,KAAK,MACtB,KAAK,eAAiB,KAAK,MAC3B,KAAK,YAAc,EACnB,KAAK,IAAMC,EAAQ,KAAO,IAC1B,KAAK,KAAOA,EAAQ,MAAQ,CAAA,EAC5B,KAAK,KAAOA,EAAQ,MAAQ,IAC9B,CAEA,WAAY,CACV,OAAO,KAAK,IAAG,EAAK,KAAK,UAAY,KAAK,GAC5C,CAEA,QAAS,CACP,YAAK,eAAiB,KAAK,MAC3B,KAAK,cACE,KAAK,KACd,CACF,CAEA,MAAMC,CAAa,CACjB,YAAYD,EAAU,GAAI,CACxB,KAAK,WAAaA,EAAQ,YAAc,IACxC,KAAK,WAAaA,EAAQ,YAAc,IACxC,KAAK,MAAQ,IAAI,IACjB,KAAK,SAAW,IAAI,IACpB,KAAK,MAAQ,CACX,KAAM,EACN,OAAQ,EACR,UAAW,EACX,cAAe,CACrB,CACE,CAEA,IAAIF,EAAK,CACP,MAAMI,EAAQ,KAAK,MAAM,IAAIJ,CAAG,EAEhC,OAAKI,EAKDA,EAAM,aACR,KAAK,QAAQJ,CAAG,EAChB,KAAK,MAAM,SACJ,OAGT,KAAK,MAAM,OAGX,KAAK,MAAM,OAAOA,CAAG,EACrB,KAAK,MAAM,IAAIA,EAAKI,CAAK,EAElBA,EAAM,WAhBX,KAAK,MAAM,SACJ,KAgBX,CAEA,IAAIJ,EAAKC,EAAOC,EAAU,CAAA,EAAI,CAO5B,IALI,KAAK,MAAM,IAAIF,CAAG,GACpB,KAAK,QAAQA,CAAG,EAIX,KAAK,MAAM,MAAQ,KAAK,YAC7B,KAAK,UAAS,EAGhB,MAAMI,EAAQ,IAAIL,EAAWC,EAAKC,EAAO,CACvC,IAAKC,EAAQ,KAAO,KAAK,WACzB,KAAMA,EAAQ,MAAQ,CAAA,EACtB,KAAMA,EAAQ,MAAQ,IAC5B,CAAK,EAED,YAAK,MAAM,IAAIF,EAAKI,CAAK,EAGzBA,EAAM,KAAK,QAASC,GAAQ,CACrB,KAAK,SAAS,IAAIA,CAAG,GACxB,KAAK,SAAS,IAAIA,EAAK,IAAI,GAAK,EAElC,KAAK,SAAS,IAAIA,CAAG,EAAE,IAAIL,CAAG,CAChC,CAAC,EAEMI,CACT,CAEA,IAAIJ,EAAK,CACP,MAAMI,EAAQ,KAAK,MAAM,IAAIJ,CAAG,EAChC,OAAKI,EACDA,EAAM,aACR,KAAK,QAAQJ,CAAG,EACT,IAEF,GALY,EAMrB,CAEA,WAAWA,EAAK,CACd,KAAK,QAAQA,CAAG,EAChB,KAAK,MAAM,eACb,CAEA,gBAAgBK,EAAK,CACnB,MAAMC,EAAO,KAAK,SAAS,IAAID,CAAG,EAClC,GAAI,CAACC,EAAM,MAAO,GAElB,IAAIC,EAAQ,EACZ,OAAAD,EAAK,QAASN,GAAQ,CACpB,KAAK,QAAQA,CAAG,EAChBO,GACF,CAAC,EAED,KAAK,SAAS,OAAOF,CAAG,EACxB,KAAK,MAAM,eAAiBE,EACrBA,CACT,CAEA,oBAAoBC,EAAS,CAC3B,MAAMC,EAAQ,IAAI,OAAOD,CAAO,EAChC,IAAID,EAAQ,EAEZ,MAAMG,EAAe,CAAA,EACrB,YAAK,MAAM,QAAQ,CAACC,EAAGX,IAAQ,CACzBS,EAAM,KAAKT,CAAG,GAChBU,EAAa,KAAKV,CAAG,CAEzB,CAAC,EAEDU,EAAa,QAASV,GAAQ,CAC5B,KAAK,QAAQA,CAAG,EAChBO,GACF,CAAC,EAED,KAAK,MAAM,eAAiBA,EACrBA,CACT,CAEA,SAASP,EAAK,CACZ,MAAMI,EAAQ,KAAK,MAAM,IAAIJ,CAAG,EAChC,OAAKI,EACEA,EAAM,MADM,IAErB,CAEA,QAAQJ,EAAK,CACX,MAAMI,EAAQ,KAAK,MAAM,IAAIJ,CAAG,EAChC,OAAOI,GAAA,YAAAA,EAAO,OAAQ,IACxB,CAEA,OAAQ,CACN,KAAK,MAAM,QACX,KAAK,SAAS,OAChB,CAEA,UAAW,CACT,MAAMQ,EACJ,KAAK,MAAM,KAAO,KAAK,MAAM,OAAS,GAChC,KAAK,MAAM,MAAQ,KAAK,MAAM,KAAO,KAAK,MAAM,QAAW,KAAK,QAAQ,CAAC,EAC3E,MAEN,MAAO,CACL,GAAG,KAAK,MACR,QAAS,GAAGA,CAAO,IACnB,KAAM,KAAK,MAAM,KACjB,QAAS,KAAK,UACpB,CACE,CAEA,QAAQZ,EAAK,CACX,MAAMI,EAAQ,KAAK,MAAM,IAAIJ,CAAG,EAC3BI,IAGLA,EAAM,KAAK,QAASC,GAAQ,CAC1B,MAAMQ,EAAU,KAAK,SAAS,IAAIR,CAAG,EACjCQ,IACFA,EAAQ,OAAOb,CAAG,EACda,EAAQ,OAAS,GACnB,KAAK,SAAS,OAAOR,CAAG,EAG9B,CAAC,EAED,KAAK,MAAM,OAAOL,CAAG,EACvB,CAEA,WAAY,CAEV,MAAMc,EAAW,KAAK,MAAM,KAAI,EAAG,KAAI,EAAG,MACtCA,IAAa,SACf,KAAK,QAAQA,CAAQ,EACrB,KAAK,MAAM,YAEf,CACF,CCrMA,MAAMC,CAAiB,CACrB,YAAYC,EAAc,CACxB,KAAK,MAAQA,EACb,KAAK,cAAgB,IAAI,GAC3B,CAMA,qBAAqBC,EAAcC,EAAcC,EAAM,CACrD,MAAMnB,EAAM,GAAGiB,CAAY,IAAIC,CAAY,GAC3C,KAAK,cAAc,IAAIlB,EAAKmB,CAAI,CAClC,CAKA,WAAWF,EAAcC,EAAcE,EAAU,CAAA,EAAI,CACnD,MAAMpB,EAAM,GAAGiB,CAAY,IAAIC,CAAY,GACrCC,EAAO,KAAK,cAAc,IAAInB,CAAG,EAEvC,GAAImB,EAAM,CACR,IAAIE,EAAc,EAClB,OAAAF,EAAK,QAASd,GAAQ,CACpB,MAAMiB,EAAkB,OAAOjB,GAAQ,WAAaA,EAAIe,CAAO,EAAIf,EACnEgB,GAAe,KAAK,MAAM,gBAAgBC,CAAe,CAC3D,CAAC,EACMD,CACT,CAEA,MAAO,EACT,CAKA,iBAAiBE,EAAYC,EAAU,CACrC,MAAMnB,EAAM,GAAGkB,CAAU,IAAIC,CAAQ,GACrC,OAAO,KAAK,MAAM,gBAAgBnB,CAAG,CACvC,CAKA,qBAAqBoB,EAAgB,CACnC,OAAO,KAAK,MAAM,gBAAgB,cAAcA,CAAc,EAAE,CAClE,CACF,CC5CA,eAAeC,EAAWV,EAAchB,EAAK2B,EAASzB,EAAU,CAAA,EAAI,CAClE,MAAM0B,EAASZ,EAAa,IAAIhB,CAAG,EACnC,GAAI4B,IAAW,KACb,MAAO,CAAE,KAAMA,EAAQ,OAAQ,QAAS,MAAO,IAGjD,MAAMC,EAAO,MAAMF,IACnB,OAAAX,EAAa,IAAIhB,EAAK6B,EAAM3B,CAAO,EAC5B,CAAE,KAAA2B,EAAM,OAAQ,UAAW,MAAO,EAAK,CAChD,CAKA,eAAeC,EAAad,EAAchB,EAAK2B,EAASzB,EAAU,CAAA,EAAI,CACpE,GAAI,CACF,MAAM2B,EAAO,MAAMF,IACnB,OAAAX,EAAa,IAAIhB,EAAK6B,EAAM3B,CAAO,EAC5B,CAAE,KAAA2B,EAAM,OAAQ,UAAW,MAAO,EAAK,CAChD,OAASE,EAAO,CACd,MAAMH,EAASZ,EAAa,SAAShB,CAAG,EACxC,GAAI4B,IAAW,KACb,MAAO,CAAE,KAAMA,EAAQ,OAAQ,QAAS,MAAO,GAAM,MAAAG,GAEvD,MAAMA,CACR,CACF,CAMA,SAASC,EAAqBhB,EAAchB,EAAK2B,EAASzB,EAAU,CAAA,EAAI,CACtE,MAAM0B,EAASZ,EAAa,SAAShB,CAAG,EAClCiC,EAAUjB,EAAa,IAAIhB,CAAG,EAGpC,IAAIkC,EAAa,KAGjB,MAAMC,EAAoBR,EAAO,EAC9B,KAAME,IACLb,EAAa,IAAIhB,EAAK6B,EAAM3B,CAAO,EAC/BA,EAAQ,eACVA,EAAQ,cAAc2B,CAAI,EAErBA,EACR,EACA,MAAOE,IACNG,EAAaH,EACT7B,EAAQ,mBACVA,EAAQ,kBAAkB6B,CAAK,EAE1B,KACR,EAEH,OAAIH,IAAW,KACN,CACL,KAAMA,EACN,OAAQ,QACR,MAAO,CAACK,EACR,aAAcE,CACpB,EAISA,EAAkB,KAAMN,GAAS,CACtC,GAAIA,IAAS,KAEX,MAAMK,GAAc,IAAI,MAAM,qDAAqD,EAErF,MAAO,CAAE,KAAAL,EAAM,OAAQ,UAAW,MAAO,GAAO,aAAc,KAChE,CAAC,CACH,CC3EA,MAAMO,EAAmB,OACnBC,EAAc,EACdC,EAAmB,IAGnBC,EAAmB,IAAI,IAE7B,MAAMC,UAAiB,KAAM,CAC3B,YAAYC,EAASC,EAAQb,EAAO,KAAM,CACxC,MAAMY,CAAO,EACb,KAAK,KAAO,WACZ,KAAK,OAASC,EACd,KAAK,KAAOb,CACd,CACF,CAEA,MAAMc,UAAuBH,CAAS,CACpC,YAAYI,EAAYf,EAAM,CAC5B,MAAM,6BAA6Be,CAAU,IAAK,IAAKf,CAAI,EAC3D,KAAK,KAAO,iBACZ,KAAK,WAAae,CACpB,CACF,CAEA,eAAeC,EAAUC,EAAU5C,EAAU,GAAI,CAC/C,KAAM,CACJ,OAAA6C,EAAS,MACT,KAAAC,EAAO,KACP,QAAAC,EAAU,CAAA,EACV,QAAAC,EAAUd,EACV,MAAAe,EAAQ,GACR,WAAAC,EAAaf,EACb,YAAAgB,EAAc,GACd,OAAAC,EAAS,KACT,QAAAC,EAAU,IACd,EAAMrD,EAEEsD,EAAM,GAAGN,CAAO,IAAIK,CAAO,GAAGT,CAAQ,GAKtCW,EAAWV,IAAW,OAASM,GAAe,CAACC,EAErD,GAAIG,EAAU,CACZ,MAAMC,EAAWnB,EAAiB,IAAIiB,CAAG,EACzC,GAAIE,EACF,OAAOA,CAEX,CAEA,MAAMC,EAAeC,EAAcJ,EAAK,CACtC,OAAAT,EACA,KAAAC,EACA,QAAAC,EACA,OAAAK,EACA,MAAAH,EACA,WAAAC,EACA,QAAS,CACb,CAAG,EAGD,OAAIK,IACFlB,EAAiB,IAAIiB,EAAKG,CAAY,EACtCA,EAAa,KACX,IAAMpB,EAAiB,OAAOiB,CAAG,EACjC,IAAMjB,EAAiB,OAAOiB,CAAG,CACvC,GAGSG,CACT,CAEA,eAAeC,EAAcJ,EAAKtD,EAAS,CACzC,KAAM,CAAE,OAAA6C,EAAQ,KAAAC,EAAM,QAAAC,EAAS,OAAAK,EAAQ,MAAAH,EAAO,WAAAC,EAAY,QAAAS,CAAO,EAAK3D,EAEhE4D,EAAe,CACnB,OAAAf,EACA,QAAS,CACP,eAAgB,mBAChB,GAAGE,CACT,CACA,EAGMK,IACFQ,EAAa,OAASR,GAGpBN,GAAQD,IAAW,QACrBe,EAAa,KAAO,KAAK,UAAUd,CAAI,GAGzC,GAAI,CACF,MAAMe,EAAW,MAAM,MAAMP,EAAKM,CAAY,EAG9C,GAAIC,EAAS,SAAW,IAAK,CAC3B,MAAMnB,EAAa,SAASmB,EAAS,QAAQ,IAAI,aAAa,GAAK,IAAK,EAAE,EACpElC,EAAO,MAAMkC,EAAS,KAAI,EAAG,MAAM,IAAM,IAAI,EAEnD,GAAIZ,GAASU,EAAUT,EAErB,aAAMY,EAAO,KAAK,IAAIpB,EAAY,CAAC,EAAI,GAAI,EACpCgB,EAAcJ,EAAK,CAAE,GAAGtD,EAAS,QAAS2D,EAAU,CAAC,CAAE,EAGhE,MAAM,IAAIlB,EAAeC,EAAYf,CAAI,CAC3C,CAGA,GAAIkC,EAAS,QAAU,KAAOZ,GAASU,EAAUT,EAAY,CAC3D,MAAMa,EAAQ3B,EAAmB,KAAK,IAAI,EAAGuB,CAAO,EACpD,aAAMG,EAAOC,CAAK,EACXL,EAAcJ,EAAK,CAAE,GAAGtD,EAAS,QAAS2D,EAAU,CAAC,CAAE,CAChE,CAGA,GAAI,CAACE,EAAS,GAAI,CAChB,MAAMlC,EAAO,MAAMkC,EAAS,KAAI,EAAG,MAAM,IAAM,IAAI,EACnD,MAAM,IAAIvB,GACRX,GAAA,YAAAA,EAAM,QAAS,8BAA8BkC,EAAS,MAAM,GAC5DA,EAAS,OACTlC,CACR,CACI,CAGA,OADa,MAAMkC,EAAS,MAE9B,OAAShC,EAAO,CAOd,GALIA,EAAM,OAAS,cAKfA,aAAiBS,EACnB,MAAMT,EAIR,GAAIoB,GAASU,EAAUT,EAAY,CACjC,MAAMa,EAAQ3B,EAAmB,KAAK,IAAI,EAAGuB,CAAO,EACpD,aAAMG,EAAOC,CAAK,EACXL,EAAcJ,EAAK,CAAE,GAAGtD,EAAS,QAAS2D,EAAU,CAAC,CAAE,CAChE,CAEA,MAAM,IAAIrB,EAAST,EAAM,QAAS,EAAG,IAAI,CAC3C,CACF,CAEA,SAASiC,EAAOE,EAAI,CAClB,OAAO,IAAI,QAASC,GAAY,WAAWA,EAASD,CAAE,CAAC,CACzD,CAGA,SAASE,EAAItB,EAAU5C,EAAU,GAAI,CACnC,OAAO2C,EAAUC,EAAU,CAAE,GAAG5C,EAAS,OAAQ,KAAK,CAAE,CAC1D"}