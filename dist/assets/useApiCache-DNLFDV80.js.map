{"version":3,"file":"useApiCache-DNLFDV80.js","sources":["../../src/hooks/useApiCache.js"],"sourcesContent":["/**\r\n * useApiCache - React hook for cached API calls with strategy selection.\r\n *\r\n * Competency: React Hook Dependencies, API Response Caching\r\n * Bug surface: object reference dependencies, stale dependencies, memory leaks,\r\n *              race conditions, missing cleanup\r\n */\r\n\r\nimport { useState, useEffect, useRef, useCallback, useMemo } from 'react';\r\nimport { CacheManager } from '../services/cache/CacheManager';\r\nimport { cacheFirst, networkFirst, staleWhileRevalidate } from '../services/cache/strategies';\r\n\r\n// Shared cache instance\r\nconst globalCache = new CacheManager({ maxEntries: 200, defaultTTL: 60000 });\r\n\r\nfunction useApiCache(fetchFn, options = {}) {\r\n  const {\r\n    cacheKey,\r\n    strategy = 'cache-first',\r\n    ttl = 60000,\r\n    tags = [],\r\n    enabled = true,\r\n    onSuccess = null,\r\n    onError = null,\r\n    staleTime = 0,\r\n  } = options;\r\n\r\n  const [state, setState] = useState({\r\n    data: null,\r\n    error: null,\r\n    isLoading: false,\r\n    isStale: false,\r\n    source: null,\r\n  });\r\n\r\n  // Use ref for fetchFn to prevent stale closures in the effect\r\n  const fetchFnRef = useRef(fetchFn);\r\n  fetchFnRef.current = fetchFn;\r\n\r\n  // Refs for callbacks to avoid resubscribing\r\n  const onSuccessRef = useRef(onSuccess);\r\n  const onErrorRef = useRef(onError);\r\n  onSuccessRef.current = onSuccess;\r\n  onErrorRef.current = onError;\r\n\r\n  // Memoize cache options to prevent dependency churn\r\n  const cacheOptions = useMemo(\r\n    () => ({ ttl, tags }),\r\n    [ttl, JSON.stringify(tags)]\r\n  );\r\n\r\n  // Request counter — stale responses (from an older execute) are discarded\r\n  const requestIdRef = useRef(0);\r\n  const isMountedRef = useRef(true);\r\n\r\n  useEffect(() => {\r\n    isMountedRef.current = true;\r\n    return () => {\r\n      isMountedRef.current = false;\r\n    };\r\n  }, []);\r\n\r\n  const execute = useCallback(async () => {\r\n    if (!cacheKey) return;\r\n\r\n    const myRequestId = ++requestIdRef.current;\r\n\r\n    setState((prev) => ({ ...prev, isLoading: true, error: null }));\r\n\r\n    // Plain fetch — no abort signal.  The requestId guard handles staleness.\r\n    const wrappedFetch = () => fetchFnRef.current();\r\n\r\n    try {\r\n      let result;\r\n\r\n      switch (strategy) {\r\n        case 'network-first':\r\n          result = await networkFirst(globalCache, cacheKey, wrappedFetch, cacheOptions);\r\n          break;\r\n        case 'stale-while-revalidate':\r\n          result = staleWhileRevalidate(globalCache, cacheKey, wrappedFetch, {\r\n            ...cacheOptions,\r\n            onRevalidated: (freshData) => {\r\n              if (isMountedRef.current && requestIdRef.current === myRequestId) {\r\n                setState((prev) => ({\r\n                  ...prev,\r\n                  data: freshData,\r\n                  isStale: false,\r\n                  source: 'network',\r\n                }));\r\n              }\r\n            },\r\n          });\r\n          // staleWhileRevalidate may return a sync result or a promise\r\n          if (result instanceof Promise) {\r\n            result = await result;\r\n          }\r\n          break;\r\n        case 'cache-first':\r\n        default:\r\n          result = await cacheFirst(globalCache, cacheKey, wrappedFetch, cacheOptions);\r\n          break;\r\n      }\r\n\r\n      if (isMountedRef.current && requestIdRef.current === myRequestId) {\r\n        setState({\r\n          data: result.data,\r\n          error: null,\r\n          isLoading: false,\r\n          isStale: result.stale || false,\r\n          source: result.source,\r\n        });\r\n\r\n        if (onSuccessRef.current) {\r\n          onSuccessRef.current(result.data);\r\n        }\r\n      }\r\n    } catch (error) {\r\n      if (error.name === 'AbortError') return;\r\n\r\n      if (isMountedRef.current && requestIdRef.current === myRequestId) {\r\n        setState((prev) => ({\r\n          ...prev,\r\n          error,\r\n          isLoading: false,\r\n        }));\r\n\r\n        if (onErrorRef.current) {\r\n          onErrorRef.current(error);\r\n        }\r\n      }\r\n    }\r\n  }, [cacheKey, strategy, cacheOptions]);\r\n\r\n  // Auto-fetch when enabled and key changes\r\n  useEffect(() => {\r\n    if (enabled && cacheKey) {\r\n      execute();\r\n    }\r\n  }, [enabled, cacheKey, execute]);\r\n\r\n  const invalidate = useCallback(() => {\r\n    if (cacheKey) {\r\n      globalCache.invalidate(cacheKey);\r\n    }\r\n  }, [cacheKey]);\r\n\r\n  const refetch = useCallback(() => {\r\n    invalidate();\r\n    return execute();\r\n  }, [invalidate, execute]);\r\n\r\n  return {\r\n    ...state,\r\n    refetch,\r\n    invalidate,\r\n    cacheStats: globalCache.getStats(),\r\n  };\r\n}\r\n\r\nexport { useApiCache, globalCache };\r\n"],"names":["globalCache","CacheManager","useApiCache","fetchFn","options","cacheKey","strategy","ttl","tags","enabled","onSuccess","onError","staleTime","state","setState","useState","fetchFnRef","useRef","onSuccessRef","onErrorRef","cacheOptions","useMemo","requestIdRef","isMountedRef","useEffect","execute","useCallback","myRequestId","prev","wrappedFetch","result","networkFirst","staleWhileRevalidate","freshData","cacheFirst","error","invalidate","refetch"],"mappings":"sHAaK,MAACA,EAAc,IAAIC,EAAa,CAAE,WAAY,IAAK,WAAY,IAAO,EAE3E,SAASC,EAAYC,EAASC,EAAU,GAAI,CAC1C,KAAM,CACJ,SAAAC,EACA,SAAAC,EAAW,cACX,IAAAC,EAAM,IACN,KAAAC,EAAO,CAAA,EACP,QAAAC,EAAU,GACV,UAAAC,EAAY,KACZ,QAAAC,EAAU,KACV,UAAAC,EAAY,CAChB,EAAMR,EAEE,CAACS,EAAOC,CAAQ,EAAIC,WAAS,CACjC,KAAM,KACN,MAAO,KACP,UAAW,GACX,QAAS,GACT,OAAQ,IACZ,CAAG,EAGKC,EAAaC,SAAOd,CAAO,EACjCa,EAAW,QAAUb,EAGrB,MAAMe,EAAeD,SAAOP,CAAS,EAC/BS,EAAaF,SAAON,CAAO,EACjCO,EAAa,QAAUR,EACvBS,EAAW,QAAUR,EAGrB,MAAMS,EAAeC,EAAAA,QACnB,KAAO,CAAE,IAAAd,EAAK,KAAAC,IACd,CAACD,EAAK,KAAK,UAAUC,CAAI,CAAC,CAC9B,EAGQc,EAAeL,SAAO,CAAC,EACvBM,EAAeN,SAAO,EAAI,EAEhCO,EAAAA,UAAU,KACRD,EAAa,QAAU,GAChB,IAAM,CACXA,EAAa,QAAU,EACzB,GACC,CAAA,CAAE,EAEL,MAAME,EAAUC,EAAAA,YAAY,SAAY,CACtC,GAAI,CAACrB,EAAU,OAEf,MAAMsB,EAAc,EAAEL,EAAa,QAEnCR,EAAUc,IAAU,CAAE,GAAGA,EAAM,UAAW,GAAM,MAAO,IAAI,EAAG,EAG9D,MAAMC,EAAe,IAAMb,EAAW,UAEtC,GAAI,CACF,IAAIc,EAEJ,OAAQxB,EAAQ,CACd,IAAK,gBACHwB,EAAS,MAAMC,EAAa/B,EAAaK,EAAUwB,EAAcT,CAAY,EAC7E,MACF,IAAK,yBACHU,EAASE,EAAqBhC,EAAaK,EAAUwB,EAAc,CACjE,GAAGT,EACH,cAAgBa,GAAc,CACxBV,EAAa,SAAWD,EAAa,UAAYK,GACnDb,EAAUc,IAAU,CAClB,GAAGA,EACH,KAAMK,EACN,QAAS,GACT,OAAQ,SAC1B,EAAkB,CAEN,CACZ,CAAW,EAEGH,aAAkB,UACpBA,EAAS,MAAMA,GAEjB,MACF,IAAK,cACL,QACEA,EAAS,MAAMI,EAAWlC,EAAaK,EAAUwB,EAAcT,CAAY,EAC3E,KACV,CAEUG,EAAa,SAAWD,EAAa,UAAYK,IACnDb,EAAS,CACP,KAAMgB,EAAO,KACb,MAAO,KACP,UAAW,GACX,QAASA,EAAO,OAAS,GACzB,OAAQA,EAAO,MACzB,CAAS,EAEGZ,EAAa,SACfA,EAAa,QAAQY,EAAO,IAAI,EAGtC,OAASK,EAAO,CACd,GAAIA,EAAM,OAAS,aAAc,OAE7BZ,EAAa,SAAWD,EAAa,UAAYK,IACnDb,EAAUc,IAAU,CAClB,GAAGA,EACH,MAAAO,EACA,UAAW,EACrB,EAAU,EAEEhB,EAAW,SACbA,EAAW,QAAQgB,CAAK,EAG9B,CACF,EAAG,CAAC9B,EAAUC,EAAUc,CAAY,CAAC,EAGrCI,EAAAA,UAAU,IAAM,CACVf,GAAWJ,GACboB,GAEJ,EAAG,CAAChB,EAASJ,EAAUoB,CAAO,CAAC,EAE/B,MAAMW,EAAaV,EAAAA,YAAY,IAAM,CAC/BrB,GACFL,EAAY,WAAWK,CAAQ,CAEnC,EAAG,CAACA,CAAQ,CAAC,EAEPgC,EAAUX,EAAAA,YAAY,KAC1BU,IACOX,EAAO,GACb,CAACW,EAAYX,CAAO,CAAC,EAExB,MAAO,CACL,GAAGZ,EACH,QAAAwB,EACA,WAAAD,EACA,WAAYpC,EAAY,SAAQ,CACpC,CACA"}